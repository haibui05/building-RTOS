#define MAX_TASKS 5

#define TASK_READY_STATE    0
#define TASK_BLOCKED_STATE  1

#define SYSTEM_CORE_CLOCK 72000000U
#define TICK_HZ 1000U   // 1ms

// Stack layout (SRAM 20KB = 0x20005000)
#define SCHED_STACK_START  0x20005000
#define IDLE_STACK_START   0x20004C00
#define T1_STACK_START     0x20004800
#define T2_STACK_START     0x20004400
#define T3_STACK_START     0x20004000
#define T4_STACK_START     0x20003C00

#define INTERRUPT_DISABLE()  __asm volatile("CPSID I")
#define INTERRUPT_ENABLE()   __asm volatile("CPSIE I")

#include "main.h"
#include "led.h"
#include "stm32f1xx_gpio.h"
#include "stm32f1xx_rcc.h"
#include "stm32f1xx_usart.h"

#define DUMMY_XPSR 0x01000000

typedef struct {
    uint32_t psp_value;
    uint32_t block_count;
    uint8_t  current_state;
    void (*task_handler)(void);
} TCB_Type;

/* global */
TCB_Type user_tasks[MAX_TASKS];
uint8_t current_task = 1;     // task1 ch?y d?u tiÃªn
uint32_t g_tick_count = 0;

/* prototypes */
void init_systick_timer(uint32_t tick_hz);
void init_scheduler_stack(uint32_t sched_top_of_stack);
void switch_sp_to_psp(void);
void init_task_stack(void);
void enable_processor_faults(void);

void idle_task_handler(void);
void task1_handler(void);
void task2_handler(void);
void task3_handler(void);
void task4_handler(void);

uint32_t get_psp_value(void);
void save_psp_value(uint32_t psp);
void update_next_task(void);
void schedule(void);
void task_delay(uint32_t tick);

/* ================= MAIN ================= */
int main(void)
{
		system_init_clock();
	
    enable_processor_faults();
    init_scheduler_stack(SCHED_STACK_START);
    init_task_stack();
    init_systick_timer(TICK_HZ);

    init_led_all();
    usart1_init(115200);

    switch_sp_to_psp();
    task1_handler();   // start first task

    while (1);
}

/* ================= TASKS ================= */

void idle_task_handler(void)
{
    while (1) {
        __asm volatile("WFI");
    }
}

void task1_handler(void)
{
    while (1) {
        led_on(GPIO_PIN_0);
        task_delay(1000);
        led_off(GPIO_PIN_0);
        task_delay(1000);
    }
}

void task2_handler(void)
{
    while (1) {
        led_on(GPIO_PIN_1);
        task_delay(500);
        led_off(GPIO_PIN_1);
        task_delay(500);
    }
}

void task3_handler(void)
{
    while (1) {
        led_on(GPIO_PIN_2);
        task_delay(250);
        led_off(GPIO_PIN_2);
        task_delay(250);
    }
}

void task4_handler(void)
{
    while (1) {
        led_on(GPIO_PIN_3);
        task_delay(125);
        led_off(GPIO_PIN_3);
        task_delay(125);
    }
}

/* ================= INIT STACK ================= */

void init_task_stack(void)
{
    user_tasks[0].task_handler = idle_task_handler;
    user_tasks[1].task_handler = task1_handler;
    user_tasks[2].task_handler = task2_handler;
    user_tasks[3].task_handler = task3_handler;
    user_tasks[4].task_handler = task4_handler;

    user_tasks[0].psp_value = IDLE_STACK_START;
    user_tasks[1].psp_value = T1_STACK_START;
    user_tasks[2].psp_value = T2_STACK_START;
    user_tasks[3].psp_value = T3_STACK_START;
    user_tasks[4].psp_value = T4_STACK_START;

    for (int i = 0; i < MAX_TASKS; i++) {
        user_tasks[i].current_state = TASK_READY_STATE;

        uint32_t *psp = (uint32_t*)user_tasks[i].psp_value;

        *(--psp) = DUMMY_XPSR;                              // xPSR
        *(--psp) = (uint32_t)user_tasks[i].task_handler;   // PC
        *(--psp) = 0xFFFFFFFD;                             // LR

        for (int j = 0; j < 13; j++) {
            *(--psp) = 0;                                  // R12..R4
        }

        user_tasks[i].psp_value = (uint32_t)psp;
    }
}

/* ================= SYSTICK ================= */

void init_systick_timer(uint32_t tick_hz)
{
    uint32_t *pLOAD = (uint32_t*)0xE000E014;
    uint32_t *pCTRL = (uint32_t*)0xE000E010;

    uint32_t count = (SYSTEM_CORE_CLOCK / tick_hz) - 1;

    *pLOAD = count;
    *pCTRL |= (1 << 2); // CLKSOURCE
    *pCTRL |= (1 << 1); // TICKINT
    *pCTRL |= (1 << 0); // ENABLE
}

void SysTick_Handler(void)
{
    g_tick_count++;

    for (int i = 1; i < MAX_TASKS; i++) {
        if (user_tasks[i].current_state == TASK_BLOCKED_STATE) {
            if (user_tasks[i].block_count <= g_tick_count) {
                user_tasks[i].current_state = TASK_READY_STATE;
            }
        }
    }

    schedule();
}

/* ================= SCHEDULER ================= */

void schedule(void)
{
    uint32_t *pICSR = (uint32_t*)0xE000ED04;
    *pICSR |= (1 << 28);   // pend PendSV
}

void update_next_task(void)
{
    for (int i = 0; i < MAX_TASKS; i++) {
        current_task++;
        current_task %= MAX_TASKS;

        if (user_tasks[current_task].current_state == TASK_READY_STATE &&
            current_task != 0) {
            return;
        }
    }
    current_task = 0; // idle
}

uint32_t get_psp_value(void)
{
    return user_tasks[current_task].psp_value;
}

void save_psp_value(uint32_t psp)
{
    user_tasks[current_task].psp_value = psp;
}

/* ================= CONTEXT SWITCH ================= */

__attribute__((naked)) void PendSV_Handler(void)
{
    __asm volatile("MRS R0, PSP");
    __asm volatile("STMDB R0!, {R4-R11}");
    __asm volatile("PUSH {LR}");
    __asm volatile("BL save_psp_value");

    __asm volatile("BL update_next_task");
    __asm volatile("BL get_psp_value");

    __asm volatile("LDMIA R0!, {R4-R11}");
    __asm volatile("MSR PSP, R0");
    __asm volatile("POP {LR}");
    __asm volatile("BX LR");
}

/* ================= UTIL ================= */

void task_delay(uint32_t tick)
{
    INTERRUPT_DISABLE();

    user_tasks[current_task].block_count = g_tick_count + tick;
    user_tasks[current_task].current_state = TASK_BLOCKED_STATE;

    schedule();
    INTERRUPT_ENABLE();
}

__attribute__((naked)) void init_scheduler_stack(uint32_t sched_top_of_stack)
{
    __asm volatile("MSR MSP, R0");
    __asm volatile("BX LR");
}

__attribute__((naked)) void switch_sp_to_psp(void)
{
    __asm volatile("PUSH {LR}");
    __asm volatile("BL get_psp_value");
    __asm volatile("MSR PSP, R0");
    __asm volatile("POP {LR}");

    __asm volatile("MOV R0, #0x02");
    __asm volatile("MSR CONTROL, R0");
    __asm volatile("BX LR");
}

void enable_processor_faults(void)
{
    uint32_t *pSHCSR = (uint32_t*)0xE000ED24;
    *pSHCSR |= (1 << 16); // MemFault
    *pSHCSR |= (1 << 17); // BusFault
    *pSHCSR |= (1 << 18); // UsageFault
}
